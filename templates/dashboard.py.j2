#!/usr/bin/env python3
"""
Octopus Energy Dashboard for Raspberry Pi with ST7789 Display
Managed by Ansible - Configuration in group_vars/all.yml
"""
import time
import requests
from datetime import datetime, timedelta
from PIL import Image, ImageDraw, ImageFont
import sys
import os
import json
import glob

# Optional Home Assistant integration for dehumidifier monitoring
try:
    from ha_integration import should_flash_dehumidifier
    HAS_HA_INTEGRATION = True
    print("Home Assistant integration loaded")
except ImportError:
    HAS_HA_INTEGRATION = False
    print("Home Assistant integration not available (optional)")

# Try to import Display HAT Mini
try:
    from displayhatmini import DisplayHATMini
    print("Running with Display HAT Mini")
    USE_DISPLAY_HAT = True
except ImportError:
    print("ERROR: displayhatmini library not found!")
    print("Install with: pip3 install git+https://github.com/pimoroni/displayhatmini-python.git#subdirectory=library")
    sys.exit(1)

# Display configuration
WIDTH = {{ display_width }}
HEIGHT = {{ display_height }}
ROTATION = {{ display_rotation }}

# Initialize display with LED support
disp = DisplayHATMini(buffer=None)

# Override ST7789 rotation (DisplayHATMini hardcodes 180, modify internal variable)
if ROTATION != 180:
    disp.st7789._rotation = ROTATION

# Configuration
REGION = "{{ octopus_region }}"
AGILE_PRODUCT = "{{ agile_product }}"
GAS_PRODUCT = "{{ gas_product }}"
WEATHER_LAT = {{ weather_latitude }}
WEATHER_LON = {{ weather_longitude }}

# Price thresholds
THRESHOLD_CHEAP = {{ price_thresholds.cheap }}
THRESHOLD_MODERATE = {{ price_thresholds.moderate }}
THRESHOLD_EXPENSIVE = {{ price_thresholds.expensive }}

# Colors
BG_COLOR = (17, 24, 39)
TEXT_COLOR = (255, 255, 255)
BLUE = (59, 130, 246)
ORANGE = (251, 146, 60)
GREEN = (34, 197, 94)
RED = (239, 68, 68)
YELLOW = (234, 179, 8)

# Layout constants
MARGIN = 5
TITLE_Y = 5
BOX_Y_OFFSET = 30
BOX_HEIGHT = 50
BOX_LABEL_PADDING = 7
BOX_LABEL_Y_OFFSET = 3
BOX_PRICE_Y_OFFSET = 16
CHART_LABEL_SPACING = 30
CHART_BOTTOM_MARGIN = 20
GRIDLINE_INTERVAL = 10
BAR_GAP = 10
CURRENT_LINE_COLOR = (220, 220, 220)
LABEL_BRIGHT_COLOR = (245, 245, 245)
Y_AXIS_LABEL_COLOR = (200, 200, 210)
TOMORROW_LABEL_COLOR = (230, 230, 240)
TOMORROW_BG_COLOR = (40, 50, 70)
GRIDLINE_COLOR = (100, 110, 130)

# Load fonts
try:
    font_paths = [
        "/usr/share/fonts/gnu-free/FreeSansBold.ttf",
        "/usr/share/fonts/liberation-sans-fonts/LiberationSans-Bold.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
    ]

    font_path = None
    for path in font_paths:
        if os.path.exists(path):
            font_path = path
            break

    if font_path:
        font_xlarge = ImageFont.truetype(font_path, 28)  # Main prices
        font_large = ImageFont.truetype(font_path, 20)   # Min/Max prices
        font_medium = ImageFont.truetype(font_path, 14)  # Tomorrow prices
        font_small = ImageFont.truetype(font_path, 11)   # X-axis labels
        font_tiny = ImageFont.truetype(font_path, 9)     # Tiny labels
        print(f"Using font: {font_path}")
    else:
        raise Exception("No font found")
except Exception as e:
    print(f"Could not load TTF fonts: {e}")
    font_xlarge = ImageFont.load_default()
    font_large = ImageFont.load_default()
    font_medium = ImageFont.load_default()
    font_small = ImageFont.load_default()
    font_tiny = ImageFont.load_default()


def get_price_color(price):
    """Get color based on price thresholds"""
    if price < THRESHOLD_CHEAP:
        return GREEN
    elif price < THRESHOLD_MODERATE:
        return BLUE
    elif price < THRESHOLD_EXPENSIVE:
        return YELLOW
    else:
        return RED


def set_led_for_price(price, flash_blue=False):
    """Set RGB LED color based on current electricity price"""
    # Use direct PWM control (displayhatmini's set_led has incorrect mapping)
    # PWM duty cycle: 100=off, 0=full on (common anode)
    # Pins: led_r_pwm=GPIO17(red), led_g_pwm=GPIO27(green), led_b_pwm=GPIO22(blue)

    # Priority 1: Dehumidifier alert (slow blue flash)
    if flash_blue:
        # Slow blue flash
        brightness = int((time.time() % 4) / 4 * 100)  # 0-100 over 4 seconds
        disp.led_r_pwm.ChangeDutyCycle(100)
        disp.led_g_pwm.ChangeDutyCycle(100)
        disp.led_b_pwm.ChangeDutyCycle(brightness)
        return

    if price is None:
        disp.led_r_pwm.ChangeDutyCycle(100)
        disp.led_g_pwm.ChangeDutyCycle(100)
        disp.led_b_pwm.ChangeDutyCycle(100)
        print("LED: Off (no price)")
        return

    # LED: Only show for cheap (green), expensive (yellow), very expensive (red)
    # No LED for moderate prices (blue range)
    if price < THRESHOLD_CHEAP:
        # Green for cheap (full brightness)
        disp.led_r_pwm.ChangeDutyCycle(100)
        disp.led_g_pwm.ChangeDutyCycle(0)
        disp.led_b_pwm.ChangeDutyCycle(100)
        print(f"LED: Green (price {price:.2f}p < {THRESHOLD_CHEAP}p)")
    elif price < THRESHOLD_MODERATE:
        # No LED for moderate (blue) prices
        disp.led_r_pwm.ChangeDutyCycle(100)
        disp.led_g_pwm.ChangeDutyCycle(100)
        disp.led_b_pwm.ChangeDutyCycle(100)
        print(f"LED: Off (price {price:.2f}p, {THRESHOLD_CHEAP}p-{THRESHOLD_MODERATE}p)")
    elif price < THRESHOLD_EXPENSIVE:
        # Yellow for expensive (more red 30%, less green 60%)
        disp.led_r_pwm.ChangeDutyCycle(30)
        disp.led_g_pwm.ChangeDutyCycle(60)
        disp.led_b_pwm.ChangeDutyCycle(100)
        print(f"LED: Yellow (price {price:.2f}p, {THRESHOLD_MODERATE}p-{THRESHOLD_EXPENSIVE}p)")
    else:
        # Red for very expensive (full brightness)
        disp.led_r_pwm.ChangeDutyCycle(0)
        disp.led_g_pwm.ChangeDutyCycle(100)
        disp.led_b_pwm.ChangeDutyCycle(100)
        print(f"LED: Red (price {price:.2f}p > {THRESHOLD_EXPENSIVE}p)")


def serialize_prices_for_cache(prices):
    """Convert price list to JSON-serializable format"""
    cache_data = []
    for item in prices:
        cache_item = item.copy()
        cache_item['timestamp'] = cache_item['timestamp'].isoformat()
        cache_item['date'] = str(cache_item['date'])
        cache_data.append(cache_item)
    return cache_data


def deserialize_prices_from_cache(cached_data):
    """Convert cached JSON data back to price list"""
    prices = []
    for item in cached_data:
        item['timestamp'] = datetime.fromisoformat(item['timestamp'])
        item['date'] = item['timestamp'].date()
        prices.append(item)
    return prices


def fetch_agile_prices():
    """Fetch Agile electricity prices with caching - returns (today_prices, tomorrow_prices)"""
    try:
        today = datetime.now().date()
        tomorrow = today + timedelta(days=1)

        today_cache = f"price-data-{today.strftime('%Y-%m-%d')}.json"
        tomorrow_cache = f"price-data-{tomorrow.strftime('%Y-%m-%d')}.json"

        # Clean up old cache files
        for old_file in glob.glob("price-data-*.json"):
            try:
                file_date_str = old_file.replace('price-data-', '').replace('.json', '')
                file_date = datetime.strptime(file_date_str, '%Y-%m-%d').date()
                if file_date < today:
                    os.remove(old_file)
                    print(f"Removed old cache file: {old_file}")
            except:
                pass

        # Load from cache if available
        today_prices = []
        tomorrow_prices = []

        if os.path.exists(today_cache):
            print(f"Loading cached today prices from {today_cache}")
            with open(today_cache, 'r') as f:
                today_prices = deserialize_prices_from_cache(json.load(f))

        if os.path.exists(tomorrow_cache):
            print(f"Loading cached tomorrow prices from {tomorrow_cache}")
            with open(tomorrow_cache, 'r') as f:
                tomorrow_prices = deserialize_prices_from_cache(json.load(f))

        # If we have both from cache, return them
        if today_prices and tomorrow_prices:
            print(f"Loaded {len(today_prices)} today + {len(tomorrow_prices)} tomorrow from cache")
            return today_prices, tomorrow_prices

        # Otherwise fetch fresh data
        url = f"https://api.octopus.energy/v1/products/{AGILE_PRODUCT}/electricity-tariffs/E-1R-{AGILE_PRODUCT}-{REGION}/standard-unit-rates/"

        # Fetch today
        if not today_prices:
            params = {
                'period_from': f"{today}T00:00:00Z",
                'period_to': f"{tomorrow}T00:00:00Z"
            }
            print(f"Fetching today's prices...")
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            for item in data['results']:
                valid_from_utc = datetime.fromisoformat(item['valid_from'].replace('Z', '+00:00'))
                valid_from_local = valid_from_utc.astimezone()
                if valid_from_local.date() == today:
                    today_prices.append({
                        'hour': valid_from_local.hour,
                        'minute': valid_from_local.minute,
                        'price': item['value_inc_vat'],
                        'timestamp': valid_from_local,
                        'date': valid_from_local.date()
                    })

            today_prices.sort(key=lambda x: x['timestamp'])

            # Save today to cache
            with open(today_cache, 'w') as f:
                json.dump(serialize_prices_for_cache(today_prices), f, indent=2)
            print(f"Saved {len(today_prices)} today prices to cache")

        # Fetch tomorrow
        if not tomorrow_prices:
            day_after = tomorrow + timedelta(days=1)
            params = {
                'period_from': f"{tomorrow}T00:00:00Z",
                'period_to': f"{day_after}T00:00:00Z"
            }
            print(f"Fetching tomorrow's prices...")
            try:
                response = requests.get(url, params=params, timeout=10)
                response.raise_for_status()
                data = response.json()

                for item in data['results']:
                    valid_from_utc = datetime.fromisoformat(item['valid_from'].replace('Z', '+00:00'))
                    valid_from_local = valid_from_utc.astimezone()
                    if valid_from_local.date() == tomorrow:
                        tomorrow_prices.append({
                            'hour': valid_from_local.hour,
                            'minute': valid_from_local.minute,
                            'price': item['value_inc_vat'],
                            'timestamp': valid_from_local,
                            'date': valid_from_local.date()
                        })

                tomorrow_prices.sort(key=lambda x: x['timestamp'])

                if tomorrow_prices:
                    # Save tomorrow to cache
                    with open(tomorrow_cache, 'w') as f:
                        json.dump(serialize_prices_for_cache(tomorrow_prices), f, indent=2)
                    print(f"Saved {len(tomorrow_prices)} tomorrow prices to cache")
            except requests.RequestException as e:
                print(f"Tomorrow's prices not available yet: {e}")

        return today_prices, tomorrow_prices

    except Exception as e:
        print(f"Error fetching Agile prices: {e}")
        return [], []


def fetch_weather():
    """Fetch today's weather from Open-Meteo API - returns (min_temp, max_temp, weather_code)"""
    try:
        url = "https://api.open-meteo.com/v1/forecast"
        params = {
            'latitude': WEATHER_LAT,
            'longitude': WEATHER_LON,
            'daily': 'temperature_2m_min,temperature_2m_max,weather_code',
            'timezone': 'auto',
            'forecast_days': 1
        }

        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        min_temp = data['daily']['temperature_2m_min'][0]
        max_temp = data['daily']['temperature_2m_max'][0]
        weather_code = data['daily']['weather_code'][0]

        return min_temp, max_temp, weather_code
    except Exception as e:
        print(f"Error fetching weather: {e}")
        return None, None, None


def fetch_gas_price():
    """Fetch gas tracker price - returns (today_price, tomorrow_price)"""
    try:
        today = datetime.now().date()
        tomorrow = today + timedelta(days=1)

        url = f"https://api.octopus.energy/v1/products/{GAS_PRODUCT}/gas-tariffs/G-1R-{GAS_PRODUCT}-{REGION}/standard-unit-rates/"

        # Fetch today and tomorrow in one call
        params = {
            'period_from': f"{today}T00:00:00Z",
            'period_to': f"{tomorrow}T23:59:59Z"
        }

        print(f"Fetching gas prices...")
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        today_price = None
        tomorrow_price = None

        for item in data['results']:
            valid_from_utc = datetime.fromisoformat(item['valid_from'].replace('Z', '+00:00'))
            valid_from_local = valid_from_utc.astimezone()

            if valid_from_local.date() == today:
                today_price = item['value_inc_vat']
            elif valid_from_local.date() == tomorrow:
                tomorrow_price = item['value_inc_vat']

        print(f"Gas - Today: {today_price}p/kWh, Tomorrow: {tomorrow_price}p/kWh")
        return today_price, tomorrow_price

    except Exception as e:
        print(f"Error fetching gas price: {e}")
        return None, None


def draw_price_with_small_p(draw, x, y, price, font_main, font_small, color):
    """Draw price with smaller 'p' suffix aligned to bottom of numerals"""
    price_str = f"{price:.1f}"
    draw.text((x, y), price_str, font=font_main, fill=color)

    # Get bounding boxes to align 'p' to bottom
    main_bbox = draw.textbbox((x, y), price_str, font=font_main)
    p_bbox = draw.textbbox((0, 0), "p", font=font_small)

    # Position 'p' after the price, aligned to bottom with slight offset up
    p_x = main_bbox[2] + 1
    p_y = main_bbox[3] - (p_bbox[3] - p_bbox[1]) - 2  # Align bottom edges, 2px higher

    draw.text((p_x, p_y), "p", font=font_small, fill=color)


def get_weather_icon(weather_code):
    """Map WMO weather code to simple icon name"""
    if weather_code is None:
        return 'unknown'
    elif weather_code == 0:
        return 'sunny'
    elif weather_code in [1, 2]:
        return 'partly_cloudy'
    elif weather_code == 3:
        return 'cloudy'
    elif weather_code in [45, 48]:
        return 'foggy'
    elif weather_code in [51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82]:
        return 'rainy'
    elif weather_code in [71, 73, 75, 77, 85, 86]:
        return 'snowy'
    elif weather_code in [95, 96, 99]:
        return 'stormy'
    else:
        return 'cloudy'


def draw_weather_icon(draw, x, y, icon_type, size=16):
    """Draw weather icon with better graphics"""
    import math
    half = size // 2
    quarter = size // 4

    if icon_type == 'sunny':
        # Central sun
        center_size = int(size * 0.5)
        offset = (size - center_size) // 2
        draw.ellipse([(x + offset, y + offset), (x + offset + center_size, y + offset + center_size)], fill=(255, 200, 0), outline=(255, 180, 0))
        # Sun rays
        ray_length = size * 0.35
        for angle in range(0, 360, 45):
            rad = math.radians(angle)
            x1 = x + half + int((half + 1) * math.cos(rad))
            y1 = y + half + int((half + 1) * math.sin(rad))
            x2 = x + half + int((half + ray_length) * math.cos(rad))
            y2 = y + half + int((half + ray_length) * math.sin(rad))
            draw.line([(x1, y1), (x2, y2)], fill=(255, 200, 0), width=2)

    elif icon_type == 'partly_cloudy':
        # Sun in upper left
        sun_x, sun_y = x + quarter, y + quarter - 1
        draw.ellipse([(sun_x, sun_y), (sun_x + half - 2, sun_y + half - 2)], fill=(255, 200, 0))
        # Small rays
        for angle in [315, 0, 45]:
            rad = math.radians(angle)
            sx = sun_x + quarter
            sy = sun_y + quarter
            x1 = sx + int(quarter * 0.7 * math.cos(rad))
            y1 = sy + int(quarter * 0.7 * math.sin(rad))
            x2 = sx + int(quarter * 1.4 * math.cos(rad))
            y2 = sy + int(quarter * 1.4 * math.sin(rad))
            draw.line([(x1, y1), (x2, y2)], fill=(255, 200, 0), width=1)
        # Cloud
        cloud_y = y + half
        draw.ellipse([(x + 1, cloud_y), (x + half, cloud_y + half - 1)], fill=(220, 220, 220), outline=(200, 200, 200))
        draw.ellipse([(x + quarter, cloud_y - 2), (x + half + quarter, cloud_y + half - 3)], fill=(240, 240, 240), outline=(210, 210, 210))
        draw.ellipse([(x + half - 2, cloud_y), (x + size - 1, cloud_y + half - 1)], fill=(220, 220, 220), outline=(200, 200, 200))

    elif icon_type == 'cloudy':
        # Multi-layer cloud
        cloud_y = y + quarter
        draw.ellipse([(x, cloud_y + 2), (x + half - 2, cloud_y + half + 2)], fill=(190, 190, 190), outline=(170, 170, 170))
        draw.ellipse([(x + quarter - 1, cloud_y), (x + half + quarter + 1, cloud_y + half)], fill=(210, 210, 210), outline=(190, 190, 190))
        draw.ellipse([(x + half - 3, cloud_y + 3), (x + size - 1, cloud_y + half + 3)], fill=(200, 200, 200), outline=(180, 180, 180))
        draw.ellipse([(x + half - 1, cloud_y + 1), (x + size, cloud_y + half + 1)], fill=(220, 220, 220), outline=(200, 200, 200))

    elif icon_type == 'rainy':
        # Dark cloud
        cloud_y = y + 1
        draw.ellipse([(x + 1, cloud_y + 2), (x + half, cloud_y + half - 1)], fill=(140, 140, 140), outline=(120, 120, 120))
        draw.ellipse([(x + quarter, cloud_y), (x + half + quarter, cloud_y + half - 2)], fill=(160, 160, 160), outline=(140, 140, 140))
        draw.ellipse([(x + half - 2, cloud_y + 2), (x + size, cloud_y + half - 1)], fill=(150, 150, 150), outline=(130, 130, 130))
        # Rain drops
        rain_start = y + half + 1
        for i in range(4):
            rx = x + 2 + i * 3
            draw.line([(rx, rain_start), (rx + 1, rain_start + 3)], fill=(80, 140, 255), width=1)
            draw.line([(rx + 1, rain_start + 3), (rx, rain_start + 6)], fill=(80, 140, 255), width=1)

    elif icon_type == 'snowy':
        # Light cloud
        cloud_y = y + 1
        draw.ellipse([(x + 1, cloud_y + 2), (x + half, cloud_y + half - 1)], fill=(230, 230, 240), outline=(210, 210, 220))
        draw.ellipse([(x + quarter, cloud_y), (x + half + quarter, cloud_y + half - 2)], fill=(240, 240, 250), outline=(220, 220, 230))
        draw.ellipse([(x + half - 2, cloud_y + 2), (x + size, cloud_y + half - 1)], fill=(235, 235, 245), outline=(215, 215, 225))
        # Snowflakes
        snow_start = y + half + 2
        for i in range(3):
            sx = x + 3 + i * 4
            sy = snow_start + (i % 2) * 2
            # Asterisk snowflake
            draw.point((sx, sy), fill=TEXT_COLOR)
            draw.point((sx - 1, sy), fill=TEXT_COLOR)
            draw.point((sx + 1, sy), fill=TEXT_COLOR)
            draw.point((sx, sy - 1), fill=TEXT_COLOR)
            draw.point((sx, sy + 1), fill=TEXT_COLOR)

    elif icon_type == 'stormy':
        # Very dark cloud
        cloud_y = y + 1
        draw.ellipse([(x + 1, cloud_y + 2), (x + half, cloud_y + half - 1)], fill=(80, 80, 80), outline=(60, 60, 60))
        draw.ellipse([(x + quarter, cloud_y), (x + half + quarter, cloud_y + half - 2)], fill=(100, 100, 100), outline=(80, 80, 80))
        draw.ellipse([(x + half - 2, cloud_y + 2), (x + size, cloud_y + half - 1)], fill=(90, 90, 90), outline=(70, 70, 70))
        # Lightning bolt - zigzag
        bolt_x = x + half
        bolt_y = y + half
        draw.line([(bolt_x, bolt_y), (bolt_x - 2, bolt_y + 3)], fill=(255, 255, 100), width=2)
        draw.line([(bolt_x - 2, bolt_y + 3), (bolt_x, bolt_y + 5)], fill=(255, 255, 100), width=2)
        draw.line([(bolt_x, bolt_y + 5), (bolt_x - 3, bolt_y + 8)], fill=(255, 255, 100), width=2)

    else:  # foggy or unknown
        # Foggy layers
        for i in range(5):
            y_pos = y + 2 + i * 3
            line_width = size - (i % 2) * 3
            draw.line([(x + 1, y_pos), (x + line_width, y_pos)], fill=(180, 180, 190), width=1)


def draw_header(draw, now, min_temp, max_temp, weather_code):
    """Draw weather info and current time"""
    # Weather info on left: icon first, then max/min temps
    if min_temp is not None and max_temp is not None:
        # Draw weather icon first (bigger to fill header space)
        icon_type = get_weather_icon(weather_code)
        icon_x = MARGIN
        icon_y = TITLE_Y
        draw_weather_icon(draw, icon_x, icon_y, icon_type, size=22)

        # Temperature text after icon
        temp_text = f"{int(round(max_temp))}°/{int(round(min_temp))}°"
        temp_x = icon_x + 26
        draw.text((temp_x, TITLE_Y), temp_text, font=font_large, fill=TEXT_COLOR)

    # Current time on right
    time_str = now.strftime("%H:%M")
    time_bbox = draw.textbbox((0, 0), time_str, font=font_large)
    time_width = time_bbox[2] - time_bbox[0]
    draw.text((WIDTH - time_width - MARGIN, TITLE_Y), time_str, font=font_large, fill=TEXT_COLOR)


def draw_price_boxes(draw, current_price, min_price, max_price, gas_today, gas_tomorrow, has_tomorrow):
    """Draw the price information boxes at the top"""
    box_half_height = BOX_HEIGHT // 2

    # Current price box (left third)
    current_color = get_price_color(current_price) if current_price else BLUE
    draw.rectangle([(MARGIN, BOX_Y_OFFSET), (WIDTH//3 - 2, BOX_Y_OFFSET + BOX_HEIGHT)], fill=current_color)
    draw.text((MARGIN + MARGIN, BOX_Y_OFFSET + BOX_LABEL_Y_OFFSET), "Now", font=font_small, fill=LABEL_BRIGHT_COLOR)
    if current_price:
        draw_price_with_small_p(draw, MARGIN + MARGIN, BOX_Y_OFFSET + BOX_PRICE_Y_OFFSET, current_price, font_xlarge, font_medium, TEXT_COLOR)

    # Min price box (middle third, top half)
    min_color = get_price_color(min_price)
    draw.rectangle([(WIDTH//3 + 2, BOX_Y_OFFSET), (2*WIDTH//3 - 2, BOX_Y_OFFSET + box_half_height - 1)], fill=min_color)
    draw.text((WIDTH//3 + BOX_LABEL_PADDING, BOX_Y_OFFSET + BOX_LABEL_Y_OFFSET), "Min", font=font_small, fill=LABEL_BRIGHT_COLOR)
    draw_price_with_small_p(draw, WIDTH//3 + 35, BOX_Y_OFFSET + BOX_LABEL_Y_OFFSET, min_price, font_large, font_small, TEXT_COLOR)

    # Max price box (middle third, bottom half)
    max_color = get_price_color(max_price)
    draw.rectangle([(WIDTH//3 + 2, BOX_Y_OFFSET + box_half_height + 1), (2*WIDTH//3 - 2, BOX_Y_OFFSET + BOX_HEIGHT)], fill=max_color)
    draw.text((WIDTH//3 + BOX_LABEL_PADDING, BOX_Y_OFFSET + box_half_height + BOX_LABEL_Y_OFFSET), "Max", font=font_small, fill=LABEL_BRIGHT_COLOR)
    draw_price_with_small_p(draw, WIDTH//3 + 35, BOX_Y_OFFSET + box_half_height + BOX_LABEL_Y_OFFSET, max_price, font_large, font_small, TEXT_COLOR)

    # Gas price box (right third)
    draw.rectangle([(2*WIDTH//3 + 2, BOX_Y_OFFSET), (WIDTH - MARGIN, BOX_Y_OFFSET + BOX_HEIGHT)], fill=ORANGE)
    draw.text((2*WIDTH//3 + BOX_LABEL_PADDING, BOX_Y_OFFSET + BOX_LABEL_Y_OFFSET), "Gas", font=font_small, fill=(255, 250, 240))
    if gas_today:
        draw_price_with_small_p(draw, 2*WIDTH//3 + BOX_LABEL_PADDING, BOX_Y_OFFSET + BOX_PRICE_Y_OFFSET, gas_today, font_xlarge, font_medium, TEXT_COLOR)

    # Tomorrow gas price in top-right if available
    if has_tomorrow and gas_tomorrow:
        gas_box_right = WIDTH - MARGIN
        price_str = f"{gas_tomorrow:.1f}"
        price_bbox = draw.textbbox((0, 0), price_str, font=font_medium)
        price_width = price_bbox[2] - price_bbox[0]
        p_bbox = draw.textbbox((0, 0), "p", font=font_tiny)
        p_width = p_bbox[2] - p_bbox[0]
        total_price_width = price_width + p_width + 1

        # Label above the price - centered with the price
        tmrw_bbox = draw.textbbox((0, 0), "Tmrw", font=font_tiny)
        tmrw_width = tmrw_bbox[2] - tmrw_bbox[0]
        label_x = gas_box_right - total_price_width + ((total_price_width - tmrw_width) // 2)
        draw.text((label_x, BOX_Y_OFFSET + BOX_LABEL_Y_OFFSET), "Tmrw", font=font_tiny, fill=TOMORROW_LABEL_COLOR)

        # Price below the label - fully right aligned
        draw_price_with_small_p(draw, gas_box_right - total_price_width, BOX_Y_OFFSET + 14, gas_tomorrow, font_medium, font_tiny, (255, 240, 220))


def draw_chart(draw, display_prices, today_prices, tomorrow_prices, current_hour, current_minute, has_tomorrow):
    """Draw the price chart"""
    chart_y = BOX_Y_OFFSET + BOX_HEIGHT + BAR_GAP
    chart_height = HEIGHT - chart_y - CHART_BOTTOM_MARGIN
    chart_width = WIDTH - 35
    chart_x = CHART_LABEL_SPACING

    if not display_prices:
        return

    # Y-axis always includes 0, extends below for negative prices
    actual_min = min(p['price'] for p in display_prices)
    chart_min_price = min(0, actual_min)
    chart_max_price = max(p['price'] for p in display_prices)
    price_range = chart_max_price - chart_min_price if chart_max_price != chart_min_price else 1

    # Calculate bar width
    num_bars = len(display_prices)
    bar_width = chart_width // num_bars

    # Calculate where tomorrow section starts
    tomorrow_start_idx = len(today_prices)
    tomorrow_start_x = chart_x + tomorrow_start_idx * bar_width

    # Draw tomorrow background first
    if has_tomorrow and tomorrow_start_idx < len(display_prices):
        draw.rectangle([
            (tomorrow_start_x, chart_y),
            (chart_x + chart_width, chart_y + chart_height)
        ], fill=TOMORROW_BG_COLOR)

    # Draw horizontal gridlines
    for price_level in range(0, int(chart_max_price) + GRIDLINE_INTERVAL, GRIDLINE_INTERVAL):
        if price_level >= chart_min_price:
            y_pos = chart_y + chart_height - int((price_level - chart_min_price) / price_range * chart_height)
            if chart_y <= y_pos <= chart_y + chart_height:
                draw.line([(chart_x, y_pos), (chart_x + chart_width, y_pos)], fill=GRIDLINE_COLOR, width=1)
                draw.text((MARGIN, y_pos - 6), str(price_level), font=font_small, fill=Y_AXIS_LABEL_COLOR)

    # Draw bars
    for i, price_data in enumerate(display_prices):
        x = chart_x + i * bar_width
        price = price_data['price']
        hour = price_data['hour']
        minute = price_data['minute']

        bar_height = int((price - chart_min_price) / price_range * chart_height)
        y = chart_y + chart_height - bar_height
        color = get_price_color(price)

        draw.rectangle([(x, y), (x + bar_width - 2, chart_y + chart_height)], fill=color)

        # Draw current time indicator (only in today section)
        is_current = hour == current_hour and minute == current_minute // 30 * 30 and i < tomorrow_start_idx
        if is_current:
            line_x = x + bar_width // 2
            for dash_y in range(chart_y, chart_y + chart_height, 6):
                draw.line([(line_x, dash_y), (line_x, dash_y + 3)], fill=CURRENT_LINE_COLOR, width=1)

        # Draw hour labels (every 4 hours including midnight)
        if minute == 0 and (hour % 4 == 0 or hour == 0):
            hour_text = str(hour)
            text_offset = 3 if hour < 10 else 5
            text_x = x + (bar_width // 2) - text_offset
            draw.text((text_x, chart_y + chart_height + 2), hour_text, font=font_small, fill=TEXT_COLOR)

    # Draw tomorrow labels
    if has_tomorrow and tomorrow_start_idx < len(display_prices):
        draw.text((tomorrow_start_x + 3, chart_y + MARGIN), "Tmrw", font=font_medium, fill=TOMORROW_LABEL_COLOR)

        # Draw midnight label at start of tomorrow
        midnight_x = chart_x + tomorrow_start_idx * bar_width + (bar_width // 2) - 3
        draw.text((midnight_x, chart_y + chart_height + 2), "0", font=font_small, fill=TEXT_COLOR)

        # Tomorrow max electric price
        tomorrow_max = max(p['price'] for p in tomorrow_prices)
        tomorrow_max_color = get_price_color(tomorrow_max)
        chart_right = chart_x + chart_width

        # Draw "Max:" label - right aligned
        max_label = "Max:"
        max_label_bbox = draw.textbbox((0, 0), max_label, font=font_small)
        max_label_width = max_label_bbox[2] - max_label_bbox[0]
        max_label_x = chart_right - max_label_width - 2
        draw.text((max_label_x, chart_y + MARGIN), max_label, font=font_small, fill=TOMORROW_LABEL_COLOR)

        # Draw price value - right aligned, color coded, no decimal
        price_str = f"{int(round(tomorrow_max))}p"
        price_bbox = draw.textbbox((0, 0), price_str, font=font_large)
        price_width = price_bbox[2] - price_bbox[0]
        price_x = chart_right - price_width - 2
        draw.text((price_x, chart_y + BOX_PRICE_Y_OFFSET), price_str, font=font_large, fill=tomorrow_max_color)


def draw_dashboard(today_prices, tomorrow_prices, gas_today, gas_tomorrow, min_temp, max_temp, weather_code):
    """Draw the dashboard on the display"""
    img = Image.new('RGB', (WIDTH, HEIGHT), color=BG_COLOR)
    draw = ImageDraw.Draw(img)
    now = datetime.now()

    # Draw header
    draw_header(draw, now, min_temp, max_temp, weather_code)

    if not today_prices:
        draw.text((MARGIN * 2, HEIGHT//2), "Loading...", font=font_medium, fill=TEXT_COLOR)
        disp.st7789.display(img)
        return

    # Keep reference to all of today's prices (before trimming for display)
    all_today = today_prices.copy()

    # If we have tomorrow's data, show only second half of today (12 hours)
    has_tomorrow = bool(tomorrow_prices)
    if has_tomorrow and len(today_prices) >= 24:
        today_prices = today_prices[24:]  # Show hours 12-23 of today

    # Combine for display
    display_prices = today_prices + tomorrow_prices

    # Calculate current price, min, and max from complete today data (before trimming)
    current_hour = now.hour
    current_minute = now.minute
    current_price = next((p['price'] for p in all_today if p['hour'] == current_hour and p['minute'] == current_minute // 30 * 30), None)
    min_price = min(p['price'] for p in all_today)
    max_price = max(p['price'] for p in all_today)

    # Draw price boxes
    draw_price_boxes(draw, current_price, min_price, max_price, gas_today, gas_tomorrow, has_tomorrow)

    # Draw chart
    draw_chart(draw, display_prices, today_prices, tomorrow_prices, current_hour, current_minute, has_tomorrow)

    # Check for dehumidifier alert (optional Home Assistant integration)
    flash_blue = False
    if HAS_HA_INTEGRATION:
        flash_blue = should_flash_dehumidifier()

    # Set LED color based on current price (or flash blue if dehumidifier full)
    set_led_for_price(current_price, flash_blue=flash_blue)

    # Display the image
    disp.st7789.display(img)


def main():
    """Main loop"""
    print("Starting Octopus Energy Dashboard...")
    print(f"Display: {WIDTH}x{HEIGHT}, Region: {REGION}")

    disp.st7789.begin()

    # Fetch data immediately
    print("\nFetching initial data...")
    today_prices, tomorrow_prices = fetch_agile_prices()
    gas_today, gas_tomorrow = fetch_gas_price()
    min_temp, max_temp, weather_code = fetch_weather()

    # Draw once
    print("\nDrawing dashboard...")
    draw_dashboard(today_prices, tomorrow_prices, gas_today, gas_tomorrow, min_temp, max_temp, weather_code)

    # Run continuously
    last_update = time.time()
    update_interval = 300  # 5 minutes

    while True:
        try:
            current_time = time.time()

            # Update data every 5 minutes
            if current_time - last_update > update_interval:
                print("Fetching new data...")
                today_prices, tomorrow_prices = fetch_agile_prices()
                gas_today, gas_tomorrow = fetch_gas_price()
                min_temp, max_temp, weather_code = fetch_weather()
                last_update = current_time

            # Redraw display
            draw_dashboard(today_prices, tomorrow_prices, gas_today, gas_tomorrow, min_temp, max_temp, weather_code)

            time.sleep(30)  # Redraw every 30 seconds for time update

        except KeyboardInterrupt:
            print("\nShutting down...")
            break
        except Exception as e:
            print(f"Error in main loop: {e}")
            time.sleep(10)


if __name__ == "__main__":
    main()
